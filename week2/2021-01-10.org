#+TITLE: 2021-01-10

* What did I do today
- Read about polymorphism
- Finished aphyr's clojure guides
- Read chronograph for fun (but not profit)
- Published all my (non-trivial) 4clojure solutions [[../4clojure.clj][here]].
* What will I do tomorrow
- Solve hard problems on 4clojure
- Read about non-trivial problems solved in clojurey ways (from Joy of Clojure)
* Blockers
- nah
* What I learned today (+ comments on the same)
** Clojure from the ground up
- Polymorphism cheatsheet:
  *Multimethods*: works with any arbitrary object, uses dispatch function to determine what to use (which is also a performance penalty).
  *Protocols*: works only with named types (=deftype=, =defrecord=). Types can be extended to support more protocols, protocols can be extended to support more types.
  *Interfaces (definterface)*: lets you define an interface that cannot be extended to more types later. Best performance.
- =deftype= gives you a super bare-bones type, while =defrecord= gives you map-like behaviour.
- Debugging: tbh, nothing new here, aphyr's tutorial was just a general methodology to trace the source of problems, read stack traces, print debugging etc. Was a nice refresher though.
-
* Commentary: reading =chronograph= source
- I decided to look into a proper project source code sample, and I looked at =nilenso/chronograph=. I wrote comments of what I understood from it. The goal is to document the gaps in my understanding, not really to get answers to all these questions asap, since I am not too sure what is worth spending my time on atm.
- Okay, so this is a time tracker, like harvest? The readme is very descriptive about the dev setup, but lol it forgot to say what it is.
- The =defproject= definition is much bigger than anything I have encountered in the starter guides I've read so far.
  What makes sense: specifying dependencies, source paths, test paths, plugins, profiles (kinda? idk its mechanics).
  Went over my head:
  - What's different between the jar and uberjar in this project? I see both names specified, not sure which comes into play on what command.
  - =^:skip-aot=? =^:replace=? =:uberjar-exclusions=?
- Config files: clojure projects seem to use edn, which look like clojure maps. There are some weird reader macros strewn in like =#merge= and =#include=, not sure what it does. This project stores database info in the config/* part.
- =resources/migrations/*=: are these generated by some tool? they look generated, because timestamps on the filenames. I might be wrong.
- =src/cljc= seems to be stuff common to both, the cljs frontend and clj backend.
  - =spec.cljc= looks interesting. They look like Racket contracts, ie, runtime validation of data. Not sure how and when they are enforced yet.
- =src/clj= is clojure backend stuff and =src/cljs= is clojurescript frontend stuff?
  - the former seems to be using a framework(?) called =ring= which claims to be like Rack/WSGI for clojure, which is an unhelpful analogy as I am unfamiliar with either. But I can see some handlers and responses being returned.
  - =defstate=? probably from some library?
  - the latter uses reframe, and a glance at the doc page gives off esoteric functional jibberjabber vibe. Skip for now.
- what is =:gen-class=?
- could not really wrap my head around the application logic and what's going on otherwise. I don't really know what the project does either, so cannot really know what to look for.
* Misc
- Watched "simple made easy" in the weekend. Great talk and philosophy, although given the need for brevity, some things did not fully click with me, specifically when he contrasted simple and complex constructs and why some are more complected than others. I need to look for examples for me to be fully clear about it.
